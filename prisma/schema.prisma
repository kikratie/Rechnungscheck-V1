generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================
// MULTI-TENANCY & AUTH
// ============================================================

model Tenant {
  id        String   @id @default(uuid())
  name      String
  slug      String   @unique
  taxId     String?
  uidNumber String?
  address   Json?
  firmenbuchNr      String?
  country           String?  @default("AT")
  phone             String?
  email             String?
  onboardingComplete Boolean @default(false)
  settings  Json     @default("{}")
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  users              User[]
  invoices           Invoice[]
  vendors            Vendor[]
  customers          Customer[]
  bankAccounts       BankAccount[]
  bankStatements     BankStatement[]
  matchings          Matching[]
  exportConfigs      ExportConfig[]
  auditLogs          AuditLog[]
  sequentialNumbers  SequentialNumber[]
  cancelledNumbers   CancelledNumber[]
  userCompanyAccess  UserCompanyAccess[]

  @@map("tenants")
}

model User {
  id          String    @id @default(uuid())
  tenantId    String
  email       String
  passwordHash String
  firstName   String
  lastName    String
  role        UserRole  @default(ACCOUNTANT)
  isActive        Boolean   @default(true)
  lastLoginAt     DateTime?
  termsAcceptedAt DateTime?
  createdAt       DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  tenant             Tenant          @relation(fields: [tenantId], references: [id])
  auditLogs          AuditLog[]      @relation("AuditUser")
  uploadedInvoices   Invoice[]       @relation("UploadedBy")
  extractedDataEdits ExtractedData[] @relation("EditedBy")
  companyAccess      UserCompanyAccess[]

  @@unique([tenantId, email])
  @@index([tenantId])
  @@map("users")
}

enum UserRole {
  ADMIN
  ACCOUNTANT
  TAX_ADVISOR
}

// ============================================================
// BANK ACCOUNTS (Bankkonten des Mandanten)
// ============================================================

model BankAccount {
  id        String   @id @default(uuid())
  tenantId  String

  label         String
  accountType   BankAccountType @default(CHECKING)
  iban          String?
  bic           String?
  bankName      String?
  cardLastFour  String?
  isPrimary     Boolean  @default(false)
  isActive      Boolean  @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id])

  @@index([tenantId])
  @@map("bank_accounts")
}

enum BankAccountType {
  CHECKING
  SAVINGS
  CREDIT_CARD
  PAYPAL
  OTHER
}

model RefreshToken {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([expiresAt])
  @@map("refresh_tokens")
}

// ============================================================
// INVOICES & AI PROCESSING
// ============================================================

model Invoice {
  id               String   @id @default(uuid())
  tenantId         String
  belegNr          Int      @default(0)          // Fortlaufende, sichtbare Beleg-Nr. pro Tenant

  // Dokument-Metadaten
  documentType     String   @default("INVOICE") // INVOICE, CREDIT_NOTE, RECEIPT
  direction        String   @default("INCOMING") // INCOMING, OUTGOING
  ingestionChannel String   @default("UPLOAD")  // UPLOAD, EMAIL, API
  originalFileName String
  storagePath      String
  storageHash      String
  mimeType         String
  fileSizeBytes    Int

  // Denormalisierte Felder (synced from latest ExtractedData)
  vendorName       String?
  vendorUid        String?
  vendorAddress    Json?
  invoiceNumber    String?
  sequentialNumber String?
  invoiceDate      DateTime?
  deliveryDate     DateTime?
  dueDate          DateTime?
  netAmount        Decimal?  @db.Decimal(12, 2)
  vatAmount        Decimal?  @db.Decimal(12, 2)
  grossAmount      Decimal?  @db.Decimal(12, 2)
  currency         String    @default("EUR")
  vatRate          Decimal?  @db.Decimal(5, 2)
  vatBreakdown     Json?     // Array<{rate, netAmount, vatAmount}> bei gemischten USt-Sätzen

  // EUR-Schätzwert für Fremdwährungsrechnungen (informativ, für Validierungsgrenzen + Anzeige)
  estimatedEurGross Decimal?  @db.Decimal(12, 2) // ≈ EUR-Gegenwert des grossAmount
  exchangeRate      Decimal?  @db.Decimal(12, 6) // 1 EUR = X Fremdwährung (ECB-Kurs)
  exchangeRateDate  DateTime?                     // Datum des ECB-Kurses

  isReverseCharge  Boolean   @default(false)
  recipientUid     String?
  issuerEmail      String?
  issuerIban       String?

  // AI-Klassifikation
  accountNumber String?
  costCenter    String?
  category      String?

  // Validierung
  validationStatus    ValidationStatus    @default(PENDING)
  validationDetails   Json                @default("[]")
  uidValidationStatus UidValidationStatus @default(NOT_CHECKED)
  uidValidationDate   DateTime?

  // AI-Verarbeitungsstatus
  processingStatus ProcessingStatus @default(UPLOADED)
  aiConfidence     Decimal?         @db.Decimal(5, 4)
  aiRawResponse    Json?
  processingError  String?

  // Duplikaterkennung
  isDuplicate   Boolean @default(false)
  duplicateOfId String?

  // Ersatzbeleg-Verknüpfung
  replacesInvoiceId  String?  @unique  // This Ersatzbeleg replaces original invoice
  replacedByInvoiceId String? @unique  // This invoice was replaced by an Ersatzbeleg
  ersatzReason       String?           // Why the Ersatzbeleg was created

  // Archivierung (gesetzt bei Genehmigung)
  archivalNumber      String?   // Fortlaufende Nummer: "ER-2026-00001"
  archivalPrefix      String?   // "ER", "AR", "GS"
  archivedAt          DateTime?
  archivedByUserId    String?
  archivedStoragePath String?   // Pfad der gestempelten Archiv-Datei
  archivedFileName    String?   // Neuer Dateiname: ER-2026-00001_Vendor_Date.pdf
  stampFailed         Boolean   @default(false) // true wenn PDF-Stempel fehlgeschlagen
  approvalComment     String?   // Optional: Begründung bei Genehmigung trotz Warnung/Ungültig

  // Workflow
  isLocked       Boolean   @default(false)
  lockedAt       DateTime?
  lockedByUserId String?
  notes          String?

  // Lieferant (auto-verknüpft)
  vendorId String?

  // Kunde (auto-verknüpft bei OUTGOING)
  customerId   String?
  customerName String?

  // Upload-Tracking
  uploadedByUserId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant            Tenant             @relation(fields: [tenantId], references: [id])
  uploadedBy        User?              @relation("UploadedBy", fields: [uploadedByUserId], references: [id])
  vendor            Vendor?            @relation(fields: [vendorId], references: [id])
  customer          Customer?          @relation(fields: [customerId], references: [id])
  lineItems            InvoiceLineItem[]
  matchings            Matching[]
  documentVersions     DocumentVersion[]
  extractedData        ExtractedData[]
  validationResults    ValidationResult[]
  substituteDocuments  SubstituteDocument[]

  @@unique([tenantId, belegNr])
  @@unique([tenantId, archivalNumber])
  @@index([tenantId])
  @@index([tenantId, vendorName])
  @@index([tenantId, invoiceNumber])
  @@index([tenantId, invoiceDate])
  @@index([tenantId, validationStatus])
  @@index([tenantId, processingStatus])
  @@index([tenantId, direction])
  @@index([storageHash])
  @@index([vendorId])
  @@index([customerId])
  @@map("invoices")
}

model InvoiceLineItem {
  id          String   @id @default(uuid())
  invoiceId   String
  position    Int
  description String?
  quantity    Decimal? @db.Decimal(10, 3)
  unit        String?
  unitPrice   Decimal? @db.Decimal(12, 2)
  netAmount   Decimal? @db.Decimal(12, 2)
  vatRate     Decimal? @db.Decimal(5, 2)
  vatAmount   Decimal? @db.Decimal(12, 2)
  grossAmount Decimal? @db.Decimal(12, 2)
  accountNumber String?

  invoice Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  @@index([invoiceId])
  @@map("invoice_line_items")
}

model DocumentVersion {
  id              String   @id @default(uuid())
  invoiceId       String
  version         Int
  storagePath     String
  storageHash     String
  changeReason    String?
  createdByUserId String
  createdAt       DateTime @default(now())

  invoice Invoice @relation(fields: [invoiceId], references: [id])

  @@unique([invoiceId, version])
  @@index([invoiceId])
  @@map("document_versions")
}

model ExtractedData {
  id        String @id @default(uuid())
  invoiceId String
  version   Int    @default(1) // 1 = KI-Extraktion, 2+ = User-Korrektur

  // §11 UStG Pflichtmerkmale
  issuerName       String?
  issuerUid        String?
  issuerAddress    Json?    // { street, zip, city, country }
  issuerEmail      String?
  issuerIban       String?
  recipientName    String?
  recipientUid     String?
  recipientAddress Json?
  invoiceNumber    String?
  sequentialNumber String?
  invoiceDate      DateTime?
  deliveryDate     DateTime?
  dueDate          DateTime?
  description      String?  // Leistungsbeschreibung

  // Beträge
  netAmount       Decimal? @db.Decimal(12, 2)
  vatAmount       Decimal? @db.Decimal(12, 2)
  grossAmount     Decimal? @db.Decimal(12, 2)
  vatRate         Decimal? @db.Decimal(5, 2)
  vatBreakdown    Json?    // Array<{rate, netAmount, vatAmount}> bei gemischten USt-Sätzen
  currency        String   @default("EUR")
  isReverseCharge Boolean  @default(false)

  // Klassifikation
  accountNumber String?
  costCenter    String?
  category      String?

  // Steuerberater-Feedback: Lieferung/Leistung + Bewirtung
  serviceType          String?  // DELIVERY, SERVICE, BOTH
  hospitalityGuests    String?  // Bewirtete Personen (Pflicht bei Bewirtungsbelegen)
  hospitalityReason    String?  // Anlass der Bewirtung
  deductibilityPercent Int?     @default(100) // 100, 50, 0
  deductibilityNote    String?  // Begründung für eingeschränkte Abzugsfähigkeit

  // Konfidenz-Scores pro Feld (JSON: { fieldName: 0.0-1.0 })
  confidenceScores Json? @default("{}")

  // Tracking
  source          String  @default("AI") // AI, MANUAL
  pipelineStage   String? // TEXT_EXTRACTION, VISION_OCR, VISION_OCR_ENHANCED
  editedByUserId  String?
  editReason      String?

  createdAt DateTime @default(now())

  invoice  Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  editedBy User?   @relation("EditedBy", fields: [editedByUserId], references: [id])

  @@unique([invoiceId, version])
  @@index([invoiceId])
  @@map("extracted_data")
}

model ValidationResult {
  id        String @id @default(uuid())
  invoiceId String

  // Ampel
  overallStatus String // GREEN, YELLOW, RED
  amountClass   String // SMALL (≤400), STANDARD (>400), LARGE (>10000)

  // Strukturierte Prüfungen (JSON Array of ValidationCheck)
  checks Json @default("[]")

  // Kommentare
  comments String?

  // Versionsbezug
  extractedDataVersion Int

  createdAt DateTime @default(now())

  invoice Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  @@index([invoiceId])
  @@index([invoiceId, createdAt])
  @@map("validation_results")
}

// ============================================================
// SEQUENTIAL NUMBERING & ARCHIVAL
// ============================================================

model SequentialNumber {
  id         String   @id @default(uuid())
  tenantId   String
  prefix     String   // "RE", "AR", "GS"
  year       Int
  month      Int      @default(0)  // 0 = legacy (no month), 1-12 = month
  lastNumber Int      @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id])

  @@unique([tenantId, prefix, year, month])
  @@index([tenantId])
  @@map("sequential_numbers")
}

model CancelledNumber {
  id                String   @id @default(uuid())
  tenantId          String
  archivalNumber    String   // "ER-2026-00003"
  invoiceId         String?
  reason            String
  cancelledByUserId String
  cancelledAt       DateTime @default(now())

  tenant Tenant @relation(fields: [tenantId], references: [id])

  @@index([tenantId])
  @@map("cancelled_numbers")
}

enum ProcessingStatus {
  UPLOADED
  PROCESSING
  PROCESSED
  REVIEW_REQUIRED
  REJECTED
  PARKED
  ARCHIVED
  RECONCILED
  RECONCILED_WITH_DIFFERENCE
  EXPORTED
  ERROR
  REPLACED
}

enum ValidationStatus {
  PENDING
  VALID
  WARNING
  INVALID
}

enum UidValidationStatus {
  NOT_CHECKED
  VALID
  INVALID
  SERVICE_UNAVAILABLE
}

// ============================================================
// VENDORS (Lieferanten / Kunden)
// ============================================================

model Vendor {
  id       String @id @default(uuid())
  tenantId String

  name    String
  uid     String?
  address Json?    // { street, zip, city, country }
  email   String?
  phone   String?
  iban    String?
  bic     String?
  website String?
  notes   String?

  // Trust Level: NEW → VERIFIED → TRUSTED (auto-approve GREEN invoices)
  trustLevel VendorTrustLevel @default(NEW)

  // VIES-Daten (gecacht vom letzten UID-Check)
  viesName      String?
  viesAddress   String?
  viesCheckedAt DateTime?

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant   Tenant    @relation(fields: [tenantId], references: [id])
  invoices Invoice[]

  @@unique([tenantId, uid])
  @@index([tenantId])
  @@index([tenantId, name])
  @@map("vendors")
}

enum VendorTrustLevel {
  NEW
  VERIFIED
  TRUSTED
}

// ============================================================
// CUSTOMERS (Kunden — für Ausgangsrechnungen)
// ============================================================

model Customer {
  id       String @id @default(uuid())
  tenantId String

  name    String
  uid     String?    // UID des Kunden (z.B. ATU12345678)
  address Json?      // { street, zip, city, country }
  email   String?
  phone   String?
  iban    String?
  bic     String?
  website String?
  notes   String?

  // VIES-Daten (gecacht vom letzten UID-Check)
  viesName      String?
  viesAddress   String?
  viesCheckedAt DateTime?

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant   Tenant    @relation(fields: [tenantId], references: [id])
  invoices Invoice[]

  @@unique([tenantId, uid])
  @@index([tenantId])
  @@index([tenantId, name])
  @@map("customers")
}

// ============================================================
// BANK STATEMENTS & TRANSACTIONS
// ============================================================

model BankStatement {
  id               String   @id @default(uuid())
  tenantId         String

  originalFileName String
  storagePath      String
  storageHash      String
  fileFormat       String

  bankName       String?
  iban           String?
  bic            String?
  statementDate  DateTime?
  periodFrom     DateTime?
  periodTo       DateTime?
  openingBalance Decimal? @db.Decimal(12, 2)
  closingBalance Decimal? @db.Decimal(12, 2)

  processingStatus ProcessingStatus @default(UPLOADED)
  processingError  String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant       Tenant            @relation(fields: [tenantId], references: [id])
  transactions BankTransaction[]

  @@index([tenantId])
  @@map("bank_statements")
}

model BankTransaction {
  id              String @id @default(uuid())
  bankStatementId String

  transactionDate DateTime
  valueDate       DateTime?
  amount          Decimal  @db.Decimal(12, 2)
  currency        String   @default("EUR")
  counterpartName String?
  counterpartIban String?
  reference       String?
  bookingText     String?

  isMatched Boolean @default(false)

  createdAt DateTime @default(now())

  bankStatement BankStatement @relation(fields: [bankStatementId], references: [id], onDelete: Cascade)
  matchings     Matching[]

  @@index([bankStatementId])
  @@index([transactionDate])
  @@index([amount])
  @@map("bank_transactions")
}

// ============================================================
// MATCHING
// ============================================================

model Matching {
  id            String      @id @default(uuid())
  tenantId      String
  invoiceId     String
  transactionId String

  matchType   MatchType
  confidence  Decimal?    @db.Decimal(5, 4)
  matchReason String?

  status MatchStatus @default(SUGGESTED)

  confirmedByUserId String?
  confirmedAt       DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant            Tenant            @relation(fields: [tenantId], references: [id])
  invoice           Invoice           @relation(fields: [invoiceId], references: [id])
  transaction       BankTransaction   @relation(fields: [transactionId], references: [id])
  paymentDifference PaymentDifference?

  @@unique([invoiceId, transactionId])
  @@index([tenantId])
  @@index([invoiceId])
  @@index([transactionId])
  @@map("matchings")
}

enum MatchType {
  AUTO
  AI_SUGGESTED
  MANUAL
}

enum MatchStatus {
  SUGGESTED
  CONFIRMED
  REJECTED
}

// ============================================================
// EXPORT
// ============================================================

model ExportConfig {
  id               String       @id @default(uuid())
  tenantId         String
  name             String
  format           ExportFormat

  columnMapping    Json
  delimiter        String  @default(";")
  dateFormat       String  @default("dd.MM.yyyy")
  decimalSeparator String  @default(",")
  encoding         String  @default("UTF-8")
  includeHeader    Boolean @default(true)

  isDefault Boolean  @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id])

  @@index([tenantId])
  @@map("export_configs")
}

model ExportLog {
  id               String       @id @default(uuid())
  tenantId         String
  exportConfigId   String?
  exportedByUserId String
  format           ExportFormat
  invoiceCount     Int
  dateFrom         DateTime?
  dateTo           DateTime?
  storagePath      String?

  createdAt DateTime @default(now())

  @@index([tenantId])
  @@map("export_logs")
}

enum ExportFormat {
  CSV_GENERIC
  BMD_CSV
  BMD_XML
}

// ============================================================
// SUBSTITUTE DOCUMENTS (Ersatzbelege)
// ============================================================

model SubstituteDocument {
  id          String   @id @default(uuid())
  invoiceId   String
  tenantId    String

  reason        String
  paymentDate   DateTime?
  amount        Decimal?  @db.Decimal(12, 2)
  description   String?
  vatDeductible Boolean   @default(true)
  vatNote       String?

  // Generated PDF
  storagePath   String?

  createdByUserId String
  createdAt       DateTime @default(now())

  invoice Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([invoiceId])
  @@map("substitute_documents")
}

// ============================================================
// PAYMENT DIFFERENCES (Zahlungsdifferenzen)
// ============================================================

model PaymentDifference {
  id          String   @id @default(uuid())
  matchingId  String   @unique

  invoiceAmount     Decimal @db.Decimal(12, 2)
  paidAmount        Decimal @db.Decimal(12, 2)
  differenceAmount  Decimal @db.Decimal(12, 2)
  differenceReason  DifferenceReason @default(OTHER)
  notes             String?
  requiresVatCorrection Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  matching Matching @relation(fields: [matchingId], references: [id], onDelete: Cascade)

  @@map("payment_differences")
}

enum DifferenceReason {
  SKONTO
  CURRENCY_DIFFERENCE
  TIP
  PARTIAL_PAYMENT
  ROUNDING
  OTHER
}

// ============================================================
// USER COMPANY ACCESS (Steuerberater Multi-Tenant)
// ============================================================

model UserCompanyAccess {
  id          String   @id @default(uuid())
  userId      String
  tenantId    String
  accessLevel AccessLevel @default(READ)

  grantedByUserId String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([userId, tenantId])
  @@index([userId])
  @@index([tenantId])
  @@map("user_company_access")
}

enum AccessLevel {
  READ
  WRITE
  ADMIN
}

// ============================================================
// AUDIT LOG
// ============================================================

model AuditLog {
  id         String  @id @default(uuid())
  tenantId   String
  userId     String?

  entityType String
  entityId   String
  action     String

  previousData Json?
  newData      Json?
  metadata     Json?

  ipAddress String?
  userAgent String?

  createdAt DateTime @default(now())

  tenant Tenant @relation(fields: [tenantId], references: [id])
  user   User?  @relation("AuditUser", fields: [userId], references: [id])

  @@index([tenantId, entityType, entityId])
  @@index([tenantId, createdAt])
  @@index([tenantId, userId])
  @@map("audit_logs")
}
